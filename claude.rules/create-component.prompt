Goal: Create a React + TypeScript component named <ComponentName> for the Next.js 15 + React 19 project.

Constraints:
- Use functional component with proper TypeScript typing
- Props must be typed and documented with JSDoc
- Add unit test with React Testing Library
- Do not hardcode secrets or API keys
- Follow accessibility best practices
- Include proper error handling and loading states
- Use TypeScript strict mode
- Follow Next.js 15 and React 19 best practices
- Use Tailwind CSS for styling
- Consider Server Component vs Client Component usage

Deliverables:
- components/<ComponentName>/index.tsx
- components/<ComponentName>/index.test.tsx
- Optional: components/<ComponentName>/types.ts (if complex props)

Template Structure:

```typescript
import React from 'react';
import { ComponentProps, WithClassName } from '@/types';

/**
 * Props for the <ComponentName> component
 * Uses utility types for consistency and type safety
 */
export interface <ComponentName>Props extends WithClassName {
  // Define component-specific props here with JSDoc comments
  // Use utility types where applicable:
  // - Disableable for components that can be disabled
  // - Loadable for components with loading states
  // - Sizeable for components with size variants
  // - Colorable for components with color variants
}

/**
 * <ComponentName> component description
 * 
 * @param props - The component props
 * @returns JSX element
 */
export const <ComponentName> = ({ className, ...props }: <ComponentName>Props) => {
  // Component implementation
  // Use type guards from @/types/utils for runtime type checking
  
  return (
    <div className={className}>
      {/* Component JSX with Tailwind CSS classes */}
    </div>
  );
};

export default <ComponentName>;
```

Next.js 15 Considerations:
- Use 'use client' directive only if component needs client-side features
- Prefer Server Components when possible for better performance
- Use Next.js Image component for images
- Implement proper loading.tsx and error.tsx for pages
- Use React 19 concurrent features when appropriate

TypeScript Utils Requirements:
- ALWAYS import utility types from '@/types' instead of creating custom ones
- Use ComponentProps, WithClassName, WithChildren for component props
- Use Disableable, Loadable, Sizeable, Colorable for common component behaviors
- Use ApiResponse<T> for API call return types
- Use AsyncState<T> for data fetching state management
- Use EventHandler<T> and AsyncEventHandler<T> for event handlers
- Use type guards (isDefined, isString, isNumber, etc.) for runtime type checking
- Use DeepPartial<T> for partial state updates
- Use RequiredBy<T, K> or PartialBy<T, K> for selective required/optional properties

Testing Requirements:
- Test rendering in both server and client environments
- Test props handling and prop validation with utility types
- Test user interactions and event handlers
- Test accessibility with jest-axe
- Test error states and loading states with AsyncState
- Test responsive design with different viewport sizes
- Validate TypeScript utility type usage in tests