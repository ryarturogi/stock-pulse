Goal: Create a Next.js 15 API route named <RouteName> for the StockPulse application following App Router conventions.

Project Context:
- StockPulse: Real-time stock tracking PWA with Finnhub API integration
- Existing routes: /api/health, /api/quote, /api/websocket-proxy, /api/push/*
- Uses Finnhub API for stock data with rate limiting considerations
- PWA with push notification capabilities

Constraints:
- Use Next.js 15 App Router API route structure (app/api/*)
- Implement proper HTTP methods (GET, POST, PUT, DELETE)
- Add TypeScript strict typing with noImplicitOverride: true
- Include proper error handling and status codes
- Add input validation and sanitization for stock data
- Use environment variables for Finnhub API key and other secrets
- Follow Finnhub API patterns and rate limiting
- Add comprehensive JSDoc documentation
- Support CORS for WebSocket proxy if needed
- Handle AbortSignal for request timeouts

Deliverables:
- app/api/<route-path>/route.ts
- Unit tests with jest.config.cjs
- Update any related types in @/core/types if needed

Template Structure:

```typescript
import { NextRequest } from 'next/server';
import { withReadOnlyMiddleware, withValidatedMiddleware, withRateLimitedMiddleware } from '@/core/middleware/api';
import { createSuccessResponse, createErrorResponse, handleApiError, validateRequiredParam } from '@/core/utils/apiResponse';
import { parsePaginationParams, paginateArray } from '@/core/utils/pagination';
import { isString, isNumber } from '@/core/types';

// Define request/response types using utility types
interface GetRequestParams {
  // Define query parameters with proper typing
}

interface PostRequestBody {
  // Define request body structure with proper typing
}

interface RouteResponseData {
  // Define response data structure
}

/**
 * API route for <RouteName>
 * @description Brief description of what this API does
 */

/**
 * Handle GET requests
 * @param request - The incoming request
 * @returns Response with data or error
 */
export const GET = withReadOnlyMiddleware(async (request: NextRequest) => {
  try {
    // Extract query parameters with type validation
    const { searchParams } = new URL(request.url);
    
    // Validate required parameters
    const param = searchParams.get('param');
    const paramError = validateRequiredParam(param, 'param');
    if (paramError) return paramError;
    
    // Process request
    // TODO: Add business logic
    
    const responseData: RouteResponseData = {
      // TODO: Add response data
    };
    
    return createSuccessResponse(responseData, 'Data retrieved successfully');
  } catch (error) {
    return handleApiError(error, 'API endpoint name');
  }
});

/**
 * Handle POST requests
 * @param request - The incoming request
 * @returns Response with created data or error
 */
export const POST = withValidatedMiddleware(
  async (request: NextRequest) => {
    try {
      // Parse request body with type validation
      const body = await request.json() as PostRequestBody;
      
      // Process request
      // TODO: Add business logic
      
      const responseData: RouteResponseData = {
        // TODO: Add response data
      };
      
      return createSuccessResponse(responseData, 'Created successfully');
    } catch (error) {
      return handleApiError(error, 'API endpoint name');
    }
  },
  ['requiredField1', 'requiredField2'] // Required fields for validation
);
```

Security Considerations:
- Validate all input parameters and request bodies
- Use environment variables for secrets (never NEXT_PUBLIC_)
- Implement proper authentication/authorization
- Add rate limiting for public endpoints
- Sanitize user input to prevent injection attacks
- Use CORS headers appropriately
- Log security events for monitoring

Error Handling:
- Return appropriate HTTP status codes
- Provide meaningful error messages (without exposing sensitive info)
- Log errors for debugging
- Handle edge cases and validation failures

StockPulse Specific Requirements:
- Use withApiMiddleware() wrappers for all API routes
- Use createSuccessResponse() and createErrorResponse() for consistent responses
- Use handleApiError() for centralized error handling
- Use validateRequiredParam() for parameter validation
- Use parsePaginationParams() and paginateArray() for list endpoints
- Use type guards (isString, isNumber, isFinnhubStockQuote, etc.) for input validation
- Handle Finnhub API integration patterns with retry logic
- Use AbortSignal.timeout() for external API calls (10s timeout)
- Follow existing patterns from /api/quote, /api/stock-symbols, and /api/symbol-search
- Support stock symbol validation with regex patterns
- Handle rate limiting gracefully for Finnhub API
- Implement fallback mechanisms for API failures
- Use proper CORS headers for WebSocket proxy routes

Available Types from @/core/types:
- FinnhubStockQuote, StockOption, WatchedStock for stock data
- FinnhubQuoteResponse for raw Finnhub API responses
- StockQuoteResponse, AvailableStocksResponse for API responses
- WebSocketMessage, TradeData for WebSocket communication
- PriceAlertNotification for push notifications

Testing Requirements:
- Use jest.config.cjs configuration
- Test all HTTP methods implemented
- Test input validation using project type guards
- Test error scenarios and API response format consistency
- Test Finnhub API integration patterns
- Mock external dependencies (Finnhub API, WebSocket connections)
- Test timeout handling with AbortSignal
- Validate stock symbol formats and sanitization